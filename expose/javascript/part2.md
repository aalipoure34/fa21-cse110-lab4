# Answers to Part 2 of the Expose Section.

- Question 1: Line 12 prints 3. This is the current value of i (which has caused the for loop to stop). Since i was setup as a var, its scope is the whole function and thus its value gets printed.
- Question 2: Line 13 prints 150. Again, discountedPrice was initialized as a var. This means that its scope is the entire function and thus its value got printed. The last time discountedPrice was updated was when the loop was still active with i having a value of 2. So it takes prices[i] or prices[2] which is 300 and multiplies it by 1 minus the discount (1-0.5 or 0.5). This gives the value of 150.
- Question 3: Line 14 also prints 150. finalPrice was initialized as a var which means that it's scope is the entire function and thus its value gets printed. The way it got to be 150 was that in the loop, it took the last value of discountedPrice (150), and does some arithmetic meant to round the discounted price to the nearest hundredths digit. In this case, post discount, the number was already a whole number so in this particular case that line was a bit pointless and it stays at 150.
-  Question 4: It returns the array containing all the discounted prices, or in this case [50, 100, 150]. The reason this happens is that we're returning discounted, which has the final discounted prices being pushed into it as the loop progresses.
-  Question 5: Line 12 gives an error. The problem is that i was initialized with let, not var. As such, once the loop finishes and we try to print i, i is out of scope and we get an error.
-  Question 6: Line 13 also gives an error. discountedPrice was initialized with let, not far. As such, it's scope is limited to the for loop and we can't try to access it outside of it.
-  Question 7: Line 14 will still print 150 as before. This is because we initialized finalPrice as a let right at the beginning of the function and it's not contained in some seperate section like the for loop. As such, its scope is still the entire function and it gets printed just fine (for why its value is 150 refer to Question 3 as the actual computation hasn't changed).
-  Question 8: The function still returns an array containing all the discounted prices and the array is still [50, 100, 150]. The thing being returned, discounted, was set up using let at the beginning of the function and not inside a special block of code. As such, we can still return it just fine after its done being populated in the for loop as its scope is the entire function. 
-  Question 9: Line 11 gives an error. The exact same thing is happening as Question 5. i is initialized with let, not var. As such its scope is the for loop and cannot be accessed outside of it.
-  Question 10: Line 12 prints 3. At the beginning of the function, length is set up to be a const. Const is very similar to let in that the scope is localized to where the variable "lives." Since length was set up in the beginning of the function and not in a special block, the scope is the entire function. The value of 3 comes from how the length of the input array is 3 and no error occurs because we never tried to modify the value of length. 
-  Question 11: The function still returns the same array of the discounted prices or [50, 100, 150]. This looks a bit strange as we're modifying discounted but its set up as a const. The reason why the code doesn't break is that we're not reassigning the array (the reference). We're just modifying the values of the array. 
-  Question 12 Part A: `student[name];`
-  Question 12 Part B: `student["Grad Year"];`
-  Question 12 Part C: `student.greeting();`
-  Question 12 Part D: `student["Favorite Teacher"]["name"];`
-  Question 12 Part E: I'm assuming by first index we mean the value at index 1 (consistent with JavaScript's indexOf). In that case, it would be `student["courseLoad"][1];`
-  Question 13 Part A: The output is '32'. The string here sort of "dominates affairs." The 2 gets turned into a string and string concatenation occurs.
-  Question 13 Part B: The output is 1. In this case, we have subtraction with a string and a number. The key difference here is the minus operator. The 3 gets converted into an int and integer subtraction occurs which gives us 1. 
-  Question 13 Part C: The output is 3. Since 3 is an integer, the value null gets turned into 0. This gives us 3 + 0 or 3.
-  Question 13 Part D: The output is '3null'. Since '3' is a string, we're dealing with string concatenation again. null gets converted into the string 'null' and then we do string concatenation to get '3null'.
-  Question 13 Part E: The output is 4. true here gets converted to the integer 1. Then we have simple integer addition and we get 4. 
-  Question 13 Part F: The output is 0. This one is interesting as we're definitely not doing string concatenation. As such, we get addition with two values that both get mapped to 0. Hence we get 0 + 0 or 0.
-  Question 13 Part G: The output is '3undefined'. This is similar to example C. undefined here gets turned into 'undefined' and then string concatenation takes place.
-  Question 13 Part H: The output is NaN. This is because we're doing subtraction, which rules out string concatenation. As such, we're trying to do numeric subtraction with undefined, which will *always* return NaN.
-  Question 14 Part A: The output is true. The '2' gets converted into the number 2 which is obviously greater than 1 so we get true.
-  Question 14 Part B: The output is false. We're comparing strings so this is a matter of which one is greater alphabetically. 2 comes after 1 in terms of alphabetical order so we get false.
-  Question 14 Part C: The output is true. The == looks at values but also does implicit type conversion. As such, from the JavaScript.info site, "when comparing values of different types, JavaScript turns theh values into numbers." So, we get 2 == 2 which is obviously true.
-  Question 14 Part D: The output is false. === looks and values and types. We having clashing types here so the output is false.
-  Question 14 Part E: The output is false. true here is turned into the number 1 and of course 1 is not equal to 2 so the output is false.
-  Question 14 Part F: The output is true. Boolean(2) basically turns the 2 into a boolean with a value of true. Thus, the values match and the types match so === gives a value of true.
-  Question 15: == looks at values only and does implict type conversion for you. === doesn't do any type conversions and the types need to match on their own (and the values still need to match of course).
-  Question 17: If we actually printed what's being returned, we would see the array [2, 4, 6]. What's happening is that the modifyArray function is called and as it's looping through the array, its using the doSomething function to modify the values of the array. So for each value of the array (like 1) the doSomething is called to multiply it by 2 and then that returned value is put into newArr. As such, we get an array that has each element of the input array multiplied by 2.
-  Question 19: The output of the code is 1 4 3 2 (each number appears on its own line in a vertical manner).